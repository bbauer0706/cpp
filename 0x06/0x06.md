[Â© 2023, A.VoÃŸ, FH Aachen, codebasedlearning.dev](mailto:cpp@codebasedlearning.dev)

# Tasks â€“ Unit0x06

---


### ğŸ‘‰ Task 'Reeds Field'

C-String.
- Legen Sie einen C-String mit einem beliebigen Text an: `char* str = â€halloâ€;`
- Legen Sie einen Zeiger auf `char` an und laufen Sie mit diesem durch das Feld str (einschlieÃŸlich des Null-Zeichens), 
  um den jeweiligen Charakter, auf den der Zeiger zeigt, auszugeben. Geben Sie den jeweils aktuellen Charakter einmal 
  als Charakter und einmal als ASCII-Wert aus. Tipp: (int)-cast fÃ¼r den ASCII-Wert.

Erweiterung:
- Geben Sie zusÃ¤tzlich auch den Wert des Zeigers, d.h. die Adresse aus. Tipp: geeigneter cast.


### ğŸ‘‰ Task 'South Birds Gale'

Zeiger, Felder.
- Definieren Sie vier Worte â€™Diesâ€™, â€™istâ€™, â€™einâ€™, â€™Satzâ€™ in einem Feld mit vier Zeigern.
- Ãœbergeben Sie dieses Feld von Zeigern einer Funktion, um dort die Worte in umgekehrter Reihenfolge auszugeben.

Erweiterung:
- Drehen Sie die Reihenfolge der Worte in dem Feld vor der Ausgabe um (nicht die Worte selbst).
- Drehen Sie auch die Worte selbst fÃ¼r die Ausgabe um.


### ğŸ‘‰ Task 'Green Mound'

new, Felder, C-Strings.
- Programmieren Sie eine Funktion â€™copyâ€™, die einen C-String als Parameter erhÃ¤lt, dynamischen Speicher mit â€™newâ€™ 
  anfordert, den Ã¼bergebenen C-String dorthin inkl. des Null-Zeichens kopiert und den Zeiger auf den neuen Speicher 
  zurÃ¼ckgibt.
- Ermitteln Sie die LÃ¤nge mithilfe einer eigenen Funktion. Schreiben Sie Testcode, der Worte kopiert und ausgibt.

Erweiterung:
- Schreiben Sie eine Funktion â€™freeâ€™ zum Freigeben des zuvor reservierten Speichers und nutzen Sie sie.
- Testen Sie ggf. mit Tools wie valgrind, ob Ihr Code Speicherlecks enthÃ¤lt.


### ğŸ‘‰ Task 'Rose Pond'

new, dynamischen Strukturen, smart pointer.
- Legen Sie eine Struktur â€™addressâ€™ an, die einen Namen und eine Tel.Nr., beides vom Typ â€™stringâ€™, enthÃ¤lt.
- Speichern Sie drei fiktive DatensÃ¤tze jeweils unter einer ID in einer â€™unordered_map<int,address*>â€™. 
  Die â€™addressâ€™-Struktur erhalten Sie dynamisch mit â€™newâ€™ und speichern nur den Zeiger.
- Geben Sie die komplette Map aus.

Erweiterung:
- Geben Sie die Daten der Map am Ende wieder frei. Testen Sie Ihren Code auf Speicherlecks.
- Verwenden Sie â€™unique_ptrâ€™ statt â€™address*â€™.


### ğŸ‘‰ Task 'Kenford'

new, dynamischen Strukturen, smart pointer.
- Realisieren Sie eine verkettete Liste, in der jeder Knoten einen â€™intâ€™ und einen Zeiger (â€™unique_ptrâ€™) auf den 
  nÃ¤chsten Knoten enthÃ¤lt. Die Liste enthÃ¤lt einen Zeiger â€™rootâ€™ auf den ersten Knoten, sowie einen ZÃ¤hler â€™countâ€™.
- Die Liste bietet eine Funktion â€™add(int n)â€™ zum HinzufÃ¼gen eines Knotens, eine Funktion â€™clearâ€™ zum LÃ¶schen 
  bzw. Freigeben aller Daten sowie einen Ausgabeoperator.

Erweiterung:
- Testen Sie Ihren Code auf Speicherlecks.
- Machen Sie aus der Liste ein Template fÃ¼r beliebige Datentypen (nicht nur â€™intâ€™).


### ğŸ‘‰ Task 'Couch Potato' - Recurring homework.

- Verstehen Sie den Code in â€™work_ptrptrâ€™ (Beispiel fÃ¼r Zeiger auf Zeiger).
- Verstehen Sie den Code in â€™work_reserveâ€™  (Unterschied Zeiger zu Referenzen).


### ğŸ‘‰ Comprehension Check

- Ich habe alle Codes und Ãœbungsthemen verstanden.
- Ich weiÃŸ was C-Strings sind.
- Ich kenne den Unterschied zwischen â€™deleteâ€™ und â€™delete[]â€™.
- Ich kann Vor- und Nachteile von Zeigern nennen.
- Ich weiÃŸ, wie â€™call-by-ref.â€™ mit Zeigern funktioniert.
- Ich kann konstante Zeiger von Zeigern auf Konstanten unterscheiden.
- Ich nutze â€™smart pointerâ€™ statt â€™raw pointerâ€™.

---

End of `Tasks â€“ Unit 0x06`
